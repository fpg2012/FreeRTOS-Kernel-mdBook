<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Heap Memory Management</title>


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title"></h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="3-heap-memory-management"><a class="header" href="#3-heap-memory-management">3 Heap Memory Management</a></h1>
<h2 id="31-introduction"><a class="header" href="#31-introduction">3.1 Introduction</a></h2>
<h3 id="311-prerequisites"><a class="header" href="#311-prerequisites">3.1.1 Prerequisites</a></h3>
<p>Being a competent C programmer is a prerequisite for using FreeRTOS, so
this chapter assumes the reader is familiar with concepts such as:</p>
<ul>
<li>The different compiling and linking phases of building a C project.</li>
<li>What the stack and heap are.</li>
<li>The standard C library <code>malloc()</code> and <code>free()</code> functions.</li>
</ul>
<h3 id="312-scope"><a class="header" href="#312-scope">3.1.2 Scope</a></h3>
<p>This chapter covers:</p>
<ul>
<li>When FreeRTOS allocates RAM.</li>
<li>The five example memory allocation schemes supplied with FreeRTOS.</li>
<li>Which memory allocation scheme to select.</li>
</ul>
<h3 id="313-switching-between-static-and-dynamic-memory-allocation"><a class="header" href="#313-switching-between-static-and-dynamic-memory-allocation">3.1.3 Switching Between Static and Dynamic Memory Allocation</a></h3>
<p>The following chapters introduce kernel objects such as tasks, queues,
semaphores, and event groups. The RAM required to hold these objects can
be allocated statically at compile-time or dynamically at run time.
Dynamic allocation reduces design and planning effort, simplifies the
API, and minimizes the RAM footprint. Static allocation is more
deterministic, removes the need to handle memory allocation failures,
and removes the risk of heap fragmentation (where the heap has enough
free memory but not in one usable contiguous block).</p>
<p>The FreeRTOS API functions that create kernel objects using statically
allocated memory are only available when <code>configSUPPORT_STATIC_ALLOCATION</code>
is set to 1 in FreeRTOSConfig.h. The FreeRTOS API functions that create
kernel objects using dynamically allocated memory are only available
when <code>configSUPPORT_DYNAMIC_ALLOCATION</code> is either set to 1 or left
undefined in FreeRTOSConfig.h. It is valid to have both constants set to
1 simultaneously.</p>
<p>More information concerning <code>configSUPPORT_STATIC_ALLOCATION</code> is in
section 3.4 Using Static Memory Allocation.</p>
<h3 id="314-using-dynamic-memory-allocation"><a class="header" href="#314-using-dynamic-memory-allocation">3.1.4 Using Dynamic Memory Allocation</a></h3>
<p>Dynamic memory allocation is a C programming concept, not a concept
specific to either FreeRTOS or multitasking. It is relevant to FreeRTOS
because kernel objects can optionally be created using dynamically
allocated memory, and the general-purpose C library <code>malloc()</code> and <code>free()</code>
functions may not be suitable for one or more of the following reasons:</p>
<ul>
<li>They are not always available on small embedded systems.</li>
<li>Their implementation can be relatively large, taking up valuable
code space.</li>
<li>They are rarely thread-safe.</li>
<li>They are not deterministic; the amount of time taken to execute the
functions will differ from call to call.</li>
<li>They can suffer from fragmentation (where the heap has enough free
memory but not in one usable contiguous block).</li>
<li>They can complicate the linker configuration.</li>
<li>They can be the source of difficult to debug errors if the heap
space is allowed to grow into memory used by other variables.</li>
</ul>
<h3 id="315-options-for-dynamic-memory-allocation"><a class="header" href="#315-options-for-dynamic-memory-allocation">3.1.5 Options for Dynamic Memory Allocation</a></h3>
<p>Early versions of FreeRTOS used a memory pools allocation scheme, where
pools of different size memory blocks are pre-allocated at compile-time,
then returned by the memory allocation functions. Although block
allocation is common in real-time systems, it was removed from FreeRTOS
because its inefficient use of RAM in really small embedded systems led to
many support requests.</p>
<p>FreeRTOS now treats memory allocation as part of the portable layer
(instead of part of the core codebase). This is because different
embedded systems have different dynamic memory allocation and timing
requirements, so a single dynamic memory allocation algorithm will only
ever be appropriate for a subset of applications. Also, removing dynamic
memory allocation from the core codebase enables application writers to
provide their own specific implementations when appropriate.</p>
<p>When FreeRTOS requires RAM it calls <code>pvPortMalloc()</code> instead of <code>malloc()</code>.
Likewise, when FreeRTOS frees previously allocated RAM it calls
<code>vPortFree()</code> instead of <code>free()</code>. <code>pvPortMalloc()</code> has the same prototype as
the standard C library <code>malloc()</code> function, and <code>vPortFree()</code> has the same
prototype as the standard C library <code>free()</code> function.</p>
<p><code>pvPortMalloc()</code> and <code>vPortFree()</code> are public functions, so they can also be
called from application code.</p>
<p>FreeRTOS comes with five example implementations of <code>pvPortMalloc()</code> and
<code>vPortFree()</code>, which are all documented in this chapter. FreeRTOS
applications can use one of the example implementations or provide their
own.</p>
<p>The five examples are defined in the heap_1.c, heap_2.c, heap_3.c,
heap_4.c and heap_5.c source files respectively, all of which are
located in the FreeRTOS/Source/portable/MemMang directory.</p>
<h2 id="32-example-memory-allocation-schemes"><a class="header" href="#32-example-memory-allocation-schemes">3.2 Example Memory Allocation Schemes</a></h2>
<h3 id="321-heap_1"><a class="header" href="#321-heap_1">3.2.1 Heap_1</a></h3>
<p>It is common for small, dedicated embedded systems to only create tasks
and other kernel objects before starting the FreeRTOS scheduler. When
this is the case, memory only gets (dynamically) allocated by the kernel
before the application starts to perform any real-time functionality,
and the memory remains allocated for the application's lifetime. This
means the chosen allocation scheme does not have to consider the more
complex memory allocation issues, such as determinism and fragmentation,
and can instead prioritise attributes such as code size and simplicity.</p>
<p>Heap_1.c implements a very basic version of <code>pvPortMalloc()</code>, and does not
implement <code>vPortFree()</code>. Applications that never delete a task or other
kernel objects have the potential to use heap_1. Some commercially
critical and safety-critical systems that would otherwise prohibit the
use of dynamic memory allocation also have the potential to use heap_1.
Critical systems often prohibit dynamic memory allocation because of the
uncertainties associated with non-determinism, memory fragmentation, and
failed allocations. Heap_1 is always deterministic and cannot fragment
memory.</p>
<p>Heap_1's implementation of <code>pvPortMalloc()</code> simply subdivides a simple
<code>uint8_t</code> array called the FreeRTOS heap into smaller blocks each time
it's called. The FreeRTOSConfig.h constant <code>configTOTAL_HEAP_SIZE</code> sets
the size of the array in bytes. Implementing the heap as a statically
allocated array makes FreeRTOS appear to consume a lot of RAM because
the heap becomes part of the FreeRTOS data.</p>
<p>Each dynamically allocated task results in two calls to <code>pvPortMalloc()</code>.
The first allocates a task control block (TCB), and the second the
task's stack. Figure 3.1 demonstrates how heap_1 subdivides the simple
array as tasks get created.</p>
<p>Referring to Figure 3.1:</p>
<ul>
<li>
<p><strong>A</strong> shows the array before creating any tasks—the entire array is free.</p>
</li>
<li>
<p><strong>B</strong> shows the array after creating one task.</p>
</li>
<li>
<p><strong>C</strong> shows the array after creating three tasks.</p>
</li>
</ul>
<p><a name="fig3.1" title="Figure 3.1 RAM being allocated from the heap\_1 array each time a task is created"></a></p>
<hr />
<p><img src="media/image05.png" alt="" /><br />
<em><strong>Figure 3.1</strong></em> <em>RAM being allocated from the heap_1 array each time a task is created</em></p>
<hr />
<h3 id="322-heap_2"><a class="header" href="#322-heap_2">3.2.2 Heap_2</a></h3>
<p>Heap_2 is superseded by heap_4, which includes enhanced functionality.
Heap_2 is kept in the FreeRTOS distribution for backward compatibility
and is not recommended for new designs.</p>
<p>Heap_2.c also works by subdividing an array dimensioned by the
<code>configTOTAL_HEAP_SIZE</code> constant. It uses a best-fit algorithm to allocate
memory, and, unlike heap_1, it does implement <code>vPortFree()</code>. Again,
implementing the heap as a statically allocated array makes FreeRTOS
appear to consume a lot of RAM because the heap becomes part of the
FreeRTOS data.</p>
<p>The best-fit algorithm ensures that <code>pvPortMalloc()</code> uses the free block
of memory that is closest in size to the number of bytes requested. For
example, consider the scenario where:</p>
<ul>
<li>The heap contains three blocks of free memory that are 5 bytes, 25
bytes, and 100 bytes, respectively.</li>
<li><code>pvPortMalloc()</code> requests 20 bytes of RAM.</li>
</ul>
<p>The smallest free block of RAM into which the requested number of bytes
fits is the 25-byte block, so <code>pvPortMalloc()</code> splits the 25-byte block
into one block of 20 bytes and one block of 5 bytes before returning
a pointer to the 20-byte block<sup class="footnote-reference"><a href="#2">1</a></sup>. The new 5-byte block remains available
for future calls to <code>pvPortMalloc()</code>.</p>
<div class="footnote-definition" id="2"><sup class="footnote-definition-label">1</sup>
<p>This is an oversimplification, because heap_2 stores information
on the block sizes within the heap area, so the sum of the two split
blocks will actually be less than 25.</p>
</div>
<p>Unlike heap_4, heap_2 does not combine adjacent free blocks into a
single larger block, so it is more susceptible to fragmentation than
heap_4. However, fragmentation is not an issue if the allocated and
subsequently freed blocks are always the same size.</p>
<p><a name="fig3.2" title="Figure 3.2 RAM being allocated and freed from the heap\_2 array as tasks are created and deleted"></a></p>
<hr />
<p><img src="media/image06.png" alt="" /><br />
<em><strong>Figure 3.2</strong></em> <em>RAM being allocated and freed from the heap_2 array as tasks are created and deleted</em></p>
<hr />
<p>Figure 3.2 demonstrates how the best-fit algorithm works when a task is
created, deleted, and created again. Referring to Figure 3.2:</p>
<ul>
<li>
<p><strong>A</strong> shows the array after allocating three tasks. A large free
block remains at the top of the array.</p>
</li>
<li>
<p><strong>B</strong> shows the array after deleting one of the tasks. The large
free block at the top of the array remains. There are now also two
smaller free blocks that previously held the TCB and stack of the
deleted task.</p>
</li>
<li>
<p><strong>C</strong> shows the situation after creating another task. Creating
the task resulted in two calls to <code>pvPortMalloc()</code> from within the
<code>xTaskCreate()</code> API function, one to allocate a new TCB and the other
to allocate the task stack. Section 3.4 of this book describes
<code>xTaskCreate()</code>.</p>
<p>Every TCB is the same size, so the best-fit algorithm reuses the block
of RAM that held the TCB of the deleted task to hold the TCB of the
created task.</p>
<p>If the size of the stack allocated to the newly created task is the
same size as that allocated to the previously deleted task, then the
best-fit algorithm reuses the block of RAM that held the stack of the
deleted task to hold the stack of the created task.</p>
<p>The larger unallocated block at the top of the array remains
untouched.</p>
</li>
</ul>
<p>Heap_2 is not deterministic but is faster than most standard library
implementations of <code>malloc()</code> and <code>free()</code>.</p>
<h3 id="323-heap_3"><a class="header" href="#323-heap_3">3.2.3 Heap_3</a></h3>
<p>Heap_3.c uses the standard library <code>malloc()</code> and <code>free()</code> functions, so the
linker configuration defines the heap size, and the
<code>configTOTAL_HEAP_SIZE</code> constant is not used.</p>
<p>Heap_3 makes <code>malloc()</code> and <code>free()</code> thread-safe by temporarily suspending
the FreeRTOS scheduler for the duration of their execution. Chapter 8,
Resource Management, covers thread safety and scheduler suspension.</p>
<h3 id="324-heap_4"><a class="header" href="#324-heap_4">3.2.4 Heap_4</a></h3>
<p>Like heap_1 and heap_2, heap_4 works by subdividing an array into
smaller blocks. As before, the array is statically allocated and
dimensioned by <code>configTOTAL_HEAP_SIZE</code>, which makes FreeRTOS appear to use
a lot of RAM as the heap becomes part of the FreeRTOS data.</p>
<p>Heap_4 uses a first-fit algorithm to allocate memory. Unlike heap_2,
heap_4 combines (coalesces) adjacent free blocks of memory into a
single larger block, which minimizes the risk of memory fragmentation.</p>
<p>The first fit algorithm ensures <code>pvPortMalloc()</code> uses the first free block
of memory that is large enough to hold the number of bytes requested.
For example, consider the scenario where:</p>
<ul>
<li>The heap contains three blocks of free memory that, in the order in
which they appear in the array, are 5 bytes, 200 bytes, and 100
bytes, respectively.</li>
<li><code>pvPortMalloc()</code> requests 20 bytes of RAM.</li>
</ul>
<p>The first free block of RAM that the requested number of bytes fits is
the 200-byte block, so <code>pvPortMalloc()</code> splits the 200-byte block into one
block of 20 bytes and one of 180 bytes<sup class="footnote-reference"><a href="#3">2</a></sup>, before returning a pointer
to the 20-byte block. The new 180-byte block remains available to future
calls to <code>pvPortMalloc()</code>.</p>
<div class="footnote-definition" id="3"><sup class="footnote-definition-label">2</sup>
<p>This is an oversimplification, because heap_4 stores information
on the block sizes within the heap area, so the sum of the two split
blocks will actually be less than 200 bytes.</p>
</div>
<p>Heap_4 combines (coalesces) adjacent free blocks into a single larger
block, minimizing the risk of fragmentation, and making it suitable for
applications that repeatedly allocate and free different-sized blocks of
RAM.</p>
<p><a name="fig3.3" title="Figure 3.3 RAM being allocated and freed from the heap\_4 array"></a></p>
<hr />
<p><img src="media/image07.png" alt="" /><br />
<em><strong>Figure 3.3</strong></em> <em>RAM being allocated and freed from the heap_4 array</em></p>
<hr />
<p>Figure 3.3 demonstrates how the heap_4 first-fit algorithm with memory
coalescence works. Referring to Figure 3.3:</p>
<ul>
<li>
<p><strong>A</strong> shows the array after creating three tasks. A large free
block remains at the top of the array.</p>
</li>
<li>
<p><strong>B</strong> shows the array after deleting one of the tasks. The large
free block at the top of the array remains. There is now another
free block where the TCB and stack of the deleted task used to be.
Unlike in the heap_2 example, heap_4 merges the two memory blocks
that previously held the TCB and stack of the deleted task,
respectively, into a larger single free block.</p>
</li>
<li>
<p><strong>C</strong> shows the situation after creating a FreeRTOS queue.
Section 5.3 of this book describes the <code>xQueueCreate()</code> API function
used to allocate queues dynamically. <code>xQueueCreate()</code> calls
<code>pvPortMalloc()</code> to allocate the RAM used by the queue. As heap_4 uses
a first-fit algorithm, <code>pvPortMalloc()</code> allocates RAM from the first
free RAM block that is large enough to hold the queue, which in
Figure 3.3, was the RAM freed by deleting the task. The queue does not
consume all the RAM in the free block, so the block is split into
two, and the unused portion remains available to future calls to
<code>pvPortMalloc()</code>.</p>
</li>
<li>
<p><strong>D</strong> shows the situation after calling <code>pvPortMalloc()</code> directly
from application code, rather than indirectly by calling a FreeRTOS
API function. The user allocated block was small enough to fit in
the first free block, which was the block between the memory
allocated to the queue, and the memory allocated to the TCB
following it.</p>
<p>The memory freed by deleting the task has now split into three
separate blocks; the first block holds the queue, the second block
holds the user allocated memory, and the third block remains free.</p>
</li>
<li>
<p><strong>E</strong> shows the situation after deleting the queue, which
automatically frees the memory allocated to the deleted queue. There
is now free memory on either side of the user allocated block.</p>
</li>
<li>
<p><strong>F</strong> shows the situation after freeing the user allocated
memory. The memory previously used by the user allocated block has
been combined with the free memory on either side to create a larger
single free block.</p>
</li>
</ul>
<p>Heap_4 is not deterministic but is faster than most standard library
implementations of <code>malloc()</code> and <code>free()</code>.</p>
<h3 id="325-heap_5"><a class="header" href="#325-heap_5">3.2.5 Heap_5</a></h3>
<p>Heap_5 uses the same allocation algorithm as heap_4. Unlike heap_4,
which is limited to allocating memory from a single array, heap_5 can
combine memory from multiple separated memory spaces into a single heap.
Heap_5 is useful when the RAM provided by the system on which FreeRTOS
is running does not appear as a single contiguous (without space) block
in the system's memory map.</p>
<h3 id="326-initialising-heap_5-the-vportdefineheapregions-api-function"><a class="header" href="#326-initialising-heap_5-the-vportdefineheapregions-api-function">3.2.6 Initialising heap_5: The vPortDefineHeapRegions() API Function</a></h3>
<p><code>vPortDefineHeapRegions()</code> initialises heap_5 by specifying the start
address and size of each separate memory area that makes up the heap
managed by heap_5. Heap_5 is the only provided heap allocation scheme
that requires explicit initialisation and can't be used until after the
call to <code>vPortDefineHeapRegions()</code>. That means kernel objects, such as
tasks, queues, and semaphores, cannot be created dynamically until after
the call to <code>vPortDefineHeapRegions()</code>.</p>
<p><a name="list3.1" title="Listing 3.1 The vPortDefineHeapRegions() API function prototype"></a></p>
<pre><code class="language-c">void vPortDefineHeapRegions( const HeapRegion_t * const pxHeapRegions );
</code></pre>
<p><em><strong>Listing 3.1</strong></em> <em>The vPortDefineHeapRegions() API function prototype</em></p>
<p><code>vPortDefineHeapRegions()</code> takes an array of <code>HeapRegion_t</code> structures as
its only parameter. Each structure defines the start address and size of
a memory block that will become part of the heap—the whole array of
structures defines the entire heap space.</p>
<p><a name="list3.2" title="Listing 3.2 The HeapRegion\_t structure"></a></p>
<pre><code class="language-c">typedef struct HeapRegion
{
    /* The start address of a block of memory that will be part of the heap.*/
    uint8_t *pucStartAddress;

    /* The size of the block of memory in bytes. */
    size_t xSizeInBytes;

} HeapRegion_t;
</code></pre>
<p><em><strong>Listing 3.2</strong></em> <em>The HeapRegion_t structure</em></p>
<p><strong>Parameters:</strong></p>
<ul>
<li>
<p><code>pxHeapRegions</code></p>
<p>A pointer to the start of an array of <code>HeapRegion_t</code> structures.
Each structure defines the start address and size of a memory block that
will become part of the heap.</p>
<p>The <code>HeapRegion_t</code> structures in the array must be ordered by start
address; the <code>HeapRegion_t</code> structure that describes the memory area with
the lowest start address must be the first structure in the array, and
the <code>HeapRegion_t</code> structure that describes the memory area with the
highest start address must be the last structure in the array.</p>
<p>Mark the end of the array with a <code>HeapRegion_t</code> structure that has its
<code>pucStartAddress</code> member set to <code>NULL</code>.</p>
</li>
</ul>
<p>By way of example, consider the hypothetical memory map shown in Figure
3.4 <strong>A</strong> which contains three separate blocks of RAM: RAM1, RAM2
and RAM3. It is assumed executable code is placed in read-only memory,
which is not shown.</p>
<p><a name="fig3.4" title="Figure 3.4 Memory Map"></a></p>
<hr />
<p><img src="media/image08.png" alt="" /><br />
<em><strong>Figure 3.4</strong></em> <em>Memory Map</em></p>
<hr />
<p>Listing 3.3 shows an array of <code>HeapRegion_t</code> structures that together
describe the three blocks of RAM in their entirety.</p>
<p><a name="list3.3" title="Listing 3.3 An array of HeapRegion\_t structures that together describe the 3 regions of RAM in their entirety"></a></p>
<pre><code class="language-c">/* Define the start address and size of the three RAM regions. */
#define RAM1_START_ADDRESS ( ( uint8_t * ) 0x00010000 )
#define RAM1_SIZE ( 64 * 1024 )

#define RAM2_START_ADDRESS ( ( uint8_t * ) 0x00020000 )
#define RAM2_SIZE ( 32 * 1024 )

#define RAM3_START_ADDRESS ( ( uint8_t * ) 0x00030000 )
#define RAM3_SIZE ( 32 * 1024 )

/* Create an array of HeapRegion_t definitions, with an index for each
   of the three RAM regions, and terminate the array with a HeapRegion_t
   structure containing a NULL address. The HeapRegion_t structures must
   appear in start address order, with the structure that contains the
   lowest start address appearing first. */
const HeapRegion_t xHeapRegions[] =
{
    { RAM1_START_ADDRESS, RAM1_SIZE },
    { RAM2_START_ADDRESS, RAM2_SIZE },
    { RAM3_START_ADDRESS, RAM3_SIZE },
    { NULL,               0         } /* Marks the end of the array. */
};

int main( void )
{
    /* Initialize heap_5. */
    vPortDefineHeapRegions( xHeapRegions );

    /* Add application code here. */
}
</code></pre>
<p><em><strong>Listing 3.3</strong></em> <em>An array of HeapRegion_t structures that together describe the 3 regions of RAM in their entirety</em></p>
<p>Although Listing 3.3 correctly describes the RAM, it does not demonstrate a
usable example because it allocates all the RAM to the heap, leaving no
RAM free for use by other variables.</p>
<p>The linking phase of the build process allocates a RAM address to each
variable. The RAM available for use by the linker is normally described
by a linker configuration file, such as a linker script. In Figure 3.4
<strong>B</strong> it is assumed the linker script included information on
RAM1, but did not include information on RAM2 or RAM3. As a result, the
linker placed variables in RAM1, leaving only the portion of RAM1 above
address 0x0001nnnn available for use by heap_5. The actual value of
0x0001nnnn depends on the combined size of all the variables included in
the application. The linker has left all of RAM2 and all of RAM3 unused,
leaving the whole of RAM2 and the whole of RAM3 available for use by
heap_5.</p>
<p>The code shown in Listing 3.3 would cause the RAM allocated to heap_5
below address 0x0001nnnn to overlap the RAM used to hold variables.
If you set the start address of the first <code>HeapRegion_t</code> structure within the
<code>xHeapRegions[]</code> array to 0x0001nnnn, rather than a start address of
0x00010000, the heap will not overlap with RAM used by the linker.
However, that is not a recommended solution because:</p>
<ul>
<li>The start address might not be easy to determine.</li>
<li>The amount of RAM used by the linker might change in future builds,
which would make an update to the start address used in the
<code>HeapRegion_t</code> structure necessary.</li>
<li>The build tools will not know, and therefore cannot warn the
application writer, if the RAM used by the linker and the RAM used
by heap_5 overlap.</li>
</ul>
<p>Listing 3.4 demonstrates a more convenient and maintainable example. It
declares an array called <code>ucHeap</code>. <code>ucHeap</code> is a normal variable, so it
becomes part of the data allocated to RAM1 by the linker. The first
<code>HeapRegion_t</code> structure in the <code>xHeapRegions</code> array describes the start
address and size of <code>ucHeap</code>, so <code>ucHeap</code> becomes part of the memory managed
by heap_5. The size of <code>ucHeap</code> can be increased until the RAM used by the
linker consumes all of RAM1, as shown in Figure 3.4 <strong>C</strong>.</p>
<p><a name="list3.4" title="Listing 3.4 An array of HeapRegion\_t structures that describe all of RAM2, all of RAM3, but only part of RAM1"></a></p>
<pre><code class="language-c">/* Define the start address and size of the two RAM regions not used by
   the linker. */
#define RAM2_START_ADDRESS ( ( uint8_t * ) 0x00020000 )
#define RAM2_SIZE ( 32 * 1024 )

#define RAM3_START_ADDRESS ( ( uint8_t * ) 0x00030000 )
#define RAM3_SIZE ( 32 * 1024 )

/* Declare an array that will be part of the heap used by heap_5. The
   array will be placed in RAM1 by the linker. */
#define RAM1_HEAP_SIZE ( 30 * 1024 )
static uint8_t ucHeap[ RAM1_HEAP_SIZE ];

/* Create an array of HeapRegion_t definitions. Whereas in Listing 3.3 the
   first entry described all of RAM1, so heap_5 will have used all of
   RAM1, this time the first entry only describes the ucHeap array, so
   heap_5 will only use the part of RAM1 that contains the ucHeap array.
   The HeapRegion_t structures must still appear in start address order,
   with the structure that contains the lowest start address appearing first. */

const HeapRegion_t xHeapRegions[] =
{
    { ucHeap,             RAM1_HEAP_SIZE },
    { RAM2_START_ADDRESS, RAM2_SIZE },
    { RAM3_START_ADDRESS, RAM3_SIZE },
    { NULL,               0 }           /* Marks the end of the array. */
};
</code></pre>
<p><em><strong>Listing 3.4</strong></em> <em>An array of HeapRegion_t structures that describe all of RAM2, all of RAM3, but only part of RAM1</em></p>
<p>The advantages of the technique demonstrated in Listing 3.4 include:</p>
<ul>
<li>It is not necessary to use a hard-coded start address.</li>
<li>The address used in the <code>HeapRegion_t</code> structure will be set
automatically by the linker, so it will always be correct, even if the
amount of RAM used by the linker changes in future builds.</li>
<li>It is impossible for RAM allocated to heap_5 to overlap data placed
into RAM1 by the linker.</li>
<li>The application will not link if <code>ucHeap</code> is too big.</li>
</ul>
<h2 id="33-heap-related-utility-functions-and-macros"><a class="header" href="#33-heap-related-utility-functions-and-macros">3.3 Heap Related Utility Functions and Macros</a></h2>
<h3 id="331-defining-the-heap-start-address"><a class="header" href="#331-defining-the-heap-start-address">3.3.1 Defining the Heap Start Address</a></h3>
<p>Heap_1, heap_2 and heap_4 allocate memory from a statically allocated
array dimensioned by <code>configTOTAL_HEAP_SIZE</code>. This section refers to these
allocation schemes collectively as heap_n.</p>
<p>Sometimes the heap needs to be placed at a specific memory address. For
example, the stack allocated to a dynamically created task comes from
the heap, so it might be necessary to locate the heap in fast internal
memory rather than slow external memory. (See the sub-section Placing
Task Stacks in Fast Memory below for another method of allocating task
stacks in fast memory). The <code>configAPPLICATION_ALLOCATED_HEAP</code>
compile-time configuration constant enables the application to declare
the array in place of the declaration that would otherwise be in the
heap_n.c source file. Declaring the array in the application code
enables the application writer to specify its start address.</p>
<p>If <code>configAPPLICATION_ALLOCATED_HEAP</code> is set to 1 in FreeRTOSConfig.h,
the application that uses FreeRTOS must allocate a <code>uint8_t</code> array
called <code>ucHeap</code> and dimensioned by the <code>configTOTAL_HEAP_SIZE</code> constant.</p>
<p>The syntax required to place a variable at a specific memory address is
dependent on the compiler in use, so refer to your compiler's
documentation. Examples for two compilers follow:</p>
<ul>
<li>Listing 3.5 shows the syntax required by the GCC compiler to declare
the array and place the array in a memory section called <code>.my_heap</code>.</li>
<li>Listing 3.6 shows the syntax required by the IAR compiler to declare
the array and place the array at the absolute memory address
0x20000000.</li>
</ul>
<p><a name="list3.5" title="Listing 3.5 Using GCC syntax to declare the array that will be used by heap\_4, and place the array in a memory section named .my\_heap"></a></p>
<pre><code class="language-c">uint8_t ucHeap[ configTOTAL_HEAP_SIZE ] __attribute__ ( ( section( ".my_heap" ) ) );
</code></pre>
<p><em><strong>Listing 3.5</strong></em> <em>Using GCC syntax to declare the array that will be used by heap_4, and place the array in a memory section named .my_heap</em></p>
<p><a name="list3.6" title="Listing 3.6 Using IAR syntax to declare the array that will be used by heap\_4, and place the array at the absolute address 0x20000000"></a></p>
<pre><code class="language-c">uint8_t ucHeap[ configTOTAL_HEAP_SIZE ] @ 0x20000000;
</code></pre>
<p><em><strong>Listing 3.6</strong></em> <em>Using IAR syntax to declare the array that will be used by heap_4, and place the array at the absolute address 0x20000000</em></p>
<h3 id="332-the-xportgetfreeheapsize-api-function"><a class="header" href="#332-the-xportgetfreeheapsize-api-function">3.3.2 The xPortGetFreeHeapSize() API Function</a></h3>
<p>The <code>xPortGetFreeHeapSize()</code> API function returns the number of free bytes
in the heap at the time the function is called. It does not provide
information on heap fragmentation.</p>
<p><code>xPortGetFreeHeapSize()</code> is not implemented for heap_3.</p>
<p><a name="list3.7" title="Listing 3.7 The xPortGetFreeHeapSize() API function prototype"></a></p>
<pre><code class="language-c">size_t xPortGetFreeHeapSize( void );
</code></pre>
<p><em><strong>Listing 3.7</strong></em> <em>The xPortGetFreeHeapSize() API function prototype</em></p>
<p><strong>Return value:</strong></p>
<ul>
<li><code>xPortGetFreeHeapSize()</code> returns the number of bytes that remain unallocated in the heap at
the time it is called.</li>
</ul>
<h3 id="333-the-xportgetminimumeverfreeheapsize-api-function"><a class="header" href="#333-the-xportgetminimumeverfreeheapsize-api-function">3.3.3 The xPortGetMinimumEverFreeHeapSize() API Function</a></h3>
<p>The <code>xPortGetMinimumEverFreeHeapSize()</code> API function returns the minimum
number of unallocated bytes that have ever existed in the heap since the
FreeRTOS application started executing.</p>
<p>The value returned by <code>xPortGetMinimumEverFreeHeapSize()</code> indicates how
close the application has ever come to running out of heap space. For
example, if <code>xPortGetMinimumEverFreeHeapSize()</code> returns 200, then, at some
time since the application started executing, it came within 200 bytes
of running out of heap space.</p>
<p><code>xPortGetMinimumEverFreeHeapSize()</code> can also be used to optimise the heap
size. For example, if <code>xPortGetMinimumEverFreeHeapSize()</code> returns 2000
after executing the code that you know has the highest heap usage,
<code>configTOTAL_HEAP_SIZE</code> can be reduced by up to 2000 bytes.</p>
<p><code>xPortGetMinimumEverFreeHeapSize()</code> is only implemented in heap_4 and heap_5.</p>
<p><a name="list3.8" title="Listing 3.8 The xPortGetMinimumEverFreeHeapSize() API function prototype"></a></p>
<pre><code class="language-c">size_t xPortGetMinimumEverFreeHeapSize( void );
</code></pre>
<p><em><strong>Listing 3.8</strong></em> <em>The xPortGetMinimumEverFreeHeapSize() API function prototype</em></p>
<p><strong>Return value:</strong></p>
<ul>
<li><code>xPortGetMinimumEverFreeHeapSize()</code> returns the minimum number of unallocated
bytes that existed in the heap since the FreeRTOS application started executing.</li>
</ul>
<h3 id="334-the-vportgetheapstats-api-function"><a class="header" href="#334-the-vportgetheapstats-api-function">3.3.4 The vPortGetHeapStats() API Function</a></h3>
<p>Heap_4 and heap_5 implement <code>vPortGetHeapStats()</code>, which completes the
<code>HeapStats_t</code> structure pass by reference as the function's only parameter.</p>
<p>Listing 3.9 shows the <code>vPortGetHeapStats()</code> function prototype. Listing 3.10
shows the <code>HeapStats_t</code> structure members.</p>
<p><a name="list3.9" title="Listing 3.9 The vPortGetHeapStatus() API function prototype"></a></p>
<pre><code class="language-c">void vPortGetHeapStats( HeapStats_t *xHeapStats );
</code></pre>
<p><em><strong>Listing 3.9</strong></em> <em>The vPortGetHeapStatus() API function prototype</em></p>
<p><a name="list3.10" title="Listing 3.10 The HeapStatus\_t() structure"></a></p>
<pre><code class="language-c">/* Prototype of the vPortGetHeapStats() function. */
void vPortGetHeapStats( HeapStats_t *xHeapStats );

/* Definition of the HeapStats_t structure. All sizes specified in bytes. */
typedef struct xHeapStats
{
    /* The total heap size currently available - this is the sum of all the
       free blocks, not the largest available block. */
    size_t xAvailableHeapSpaceInBytes;

    /* The size of the largest free block within the heap at the time
       vPortGetHeapStats() is called. */
    size_t xSizeOfLargestFreeBlockInBytes;

    /* The size of the smallest free block within the heap at the time
       vPortGetHeapStats() is called. */
    size_t xSizeOfSmallestFreeBlockInBytes;

    /* The number of free memory blocks within the heap at the time
       vPortGetHeapStats() is called. */
    size_t xNumberOfFreeBlocks;

    /* The minimum amount of total free memory (sum of all free blocks)
       there has been in the heap since the system booted. */
    size_t xMinimumEverFreeBytesRemaining;

    /* The number of calls to pvPortMalloc() that have returned a valid
       memory block. */
    size_t xNumberOfSuccessfulAllocations;

    /* The number of calls to vPortFree() that has successfully freed a
       block of memory. */
    size_t xNumberOfSuccessfulFrees;
} HeapStats_t;
</code></pre>
<p><em><strong>Listing 3.10</strong></em> <em>The HeapStatus_t() structure</em></p>
<h3 id="335-collecting-per-task-heap-usage-statistics"><a class="header" href="#335-collecting-per-task-heap-usage-statistics">3.3.5 Collecting Per-task Heap Usage Statistics</a></h3>
<p>The <code>vTaskGetInfo()</code> API function, documented in section TBD-RB of this
book, populates a <code>TaskStatus_t</code> structure with information about a task.
If the <code>configTRACK_TASK_MEMORY_ALLOCATIONS</code> compile-time constant is set
to 1 in FreeRTOSConfig.h, the structure includes the following additional
information:</p>
<ul>
<li>The number of times the task called <code>pvPortMalloc()</code>.</li>
<li>The number of times the task called <code>vPortFree()</code>.</li>
<li>The number of heap bytes allocated by the task that have not yet
been freed by any task at the time <code>vTaskGetInfo()</code> was called.</li>
<li>The maximum amount of heap memory allocated by the task at any given
time since the task started.</li>
</ul>
<h3 id="336-malloc-failed-hook-functions"><a class="header" href="#336-malloc-failed-hook-functions">3.3.6 Malloc Failed Hook Functions</a></h3>
<p>Like the standard library <code>malloc()</code> function, <code>pvPortMalloc()</code> returns NULL
if it cannot allocate the requested amount of RAM. The malloc failed hook
(or callback) is an application-provided function that gets called if
<code>pvPortMalloc()</code> returns NULL. You must set <code>configUSE_MALLOC_FAILED_HOOK</code> to
1 in FreeRTOSConfig.h in order for the callback to occur. If the malloc failed
hook gets called inside a FreeRTOS API function that uses dynamic memory
allocation to create a kernel object, the object is not created.</p>
<p>If <code>configUSE_MALLOC_FAILED_HOOK</code> is set to 1 in FreeRTOSConfig.h, then
the application must provide a malloc failed hook function with the name
and prototype shown in Listing 3.11. The application can implement the
function in any way appropriate for the application. Many of the
provided FreeRTOS demo applications treat an allocation failure as a
fatal error, but that is not the best practice for production systems,
which should gracefully recover from allocation failures.</p>
<p><a name="list3.11" title="Listing 3.11 The malloc failed hook function name and prototype"></a></p>
<pre><code class="language-c">void vApplicationMallocFailedHook( void );
</code></pre>
<p><em><strong>Listing 3.11</strong></em> <em>The malloc failed hook function name and prototype</em></p>
<h3 id="337-placing-task-stacks-in-fast-memory"><a class="header" href="#337-placing-task-stacks-in-fast-memory">3.3.7 Placing Task Stacks in Fast Memory</a></h3>
<p>Because stacks are written to and read from at a high rate, they should
be placed in fast memory, but that might not be where you want the heap to
reside. FreeRTOS uses the <code>pvPortMallocStack()</code> and <code>vPortFreeStack()</code>
macros to optionally enable stacks that are allocated within the FreeRTOS API
code to have their own memory allocator. If you want the stack to come
from the heap managed by <code>pvPortMalloc()</code> then leave <code>pvPortMallocStack()</code>
and <code>vPortFreeStack()</code> undefined as they default to calling
<code>pvPortMalloc()</code> and <code>vPortFree()</code>, respectively. Otherwise, define the
macros to call application-provided functions as shown in Listing 3.12.</p>
<p><a name="list3.12" title="Listing 3.12 Mapping the pvPortMallocStack() and vPortFreeStack() macros to an application defined memory allcator"></a></p>
<pre><code class="language-c">/* Functions provided by the application writer than allocate and free 
   memory from a fast area of RAM. */

void *pvMallocFastMemory( size_t xWantedSize );

void vPortFreeFastMemory( void *pvBlockToFree );

/* Add the following to FreeRTOSConfig.h to map the pvPortMallocStack()
   and vPortFreeStack() macros to the functions that use fast memory. */

#define pvPortMallocStack( x ) pvMallocFastMemory( x )

#define vPortFreeStack( x ) vPortFreeFastMemory( x )
</code></pre>
<p><em><strong>Listing 3.12</strong></em> <em>Mapping the pvPortMallocStack() and vPortFreeStack() macros to an application defined memory allcator</em></p>
<h2 id="34-using-static-memory-allocation"><a class="header" href="#34-using-static-memory-allocation">3.4 Using Static Memory Allocation</a></h2>
<p>Section 3.1.4 lists some of the disadvantages that come with dynamic memory allocation. To avoid those issues, static
memory allocation allows the developer to explicity create every memory block needed by the application. This has the
following advantages:</p>
<ul>
<li>All required memory is known at compile time.</li>
<li>All memory is deterministic.</li>
</ul>
<p>There are other advantages, but with these advantages come a few complications. The main complication is the addition of a
few additional user functions to manage some kernel memory, and the second complication is the need to ensure all static
memory is declared in a suitable scope.</p>
<h3 id="341-enabling-static-memory-allocation"><a class="header" href="#341-enabling-static-memory-allocation">3.4.1 Enabling Static Memory Allocation</a></h3>
<p>Static memory allocation is enabled by setting <code>configSUPPORT_STATIC_ALLOCATION</code> to 1 in FreeRTOSConfig.h.  When this
configuration is enabled, the kernel enables all the <code>static</code> versions of the kernel functions. These are:</p>
<ul>
<li><code>xTaskCreateStatic</code></li>
<li><code>xEventGroupCreateStatic</code></li>
<li><code>xEventGroupGetStaticBuffer</code></li>
<li><code>xQueueGenericCreateStatic</code></li>
<li><code>xQueueGenericGetStaticBuffers</code></li>
<li><code>xQueueCreateMutexStatic</code>
<ul>
<li><em>if <code>configUSE_MUTEXES</code> is 1</em></li>
</ul>
</li>
<li><code>xQueueCreateCountingSemaphoreStatic</code>
<ul>
<li><em>if <code>configUSE_COUNTING_SEMAPHORES</code> is 1</em></li>
</ul>
</li>
<li><code>xStreamBufferGenericCreateStatic</code></li>
<li><code>xStreamBufferGetStaticBuffers</code></li>
<li><code>xTimerCreateStatic</code>
<ul>
<li><em>if <code>configUSE_TIMERS</code> is 1</em></li>
</ul>
</li>
<li><code>xTimerGetStaticBuffer</code>
<ul>
<li><em>if <code>configUSE_TIMERS</code> is 1</em></li>
</ul>
</li>
</ul>
<p>These functions will be explained in the appropriate chapters in this book.</p>
<h3 id="342-static-internal-kernel-memory"><a class="header" href="#342-static-internal-kernel-memory">3.4.2 Static Internal Kernel Memory</a></h3>
<p>When the static memory allocator is enabled, the idle task and the timer task (if enabled) will use static memory supplied
by user functions. These user functions are:</p>
<ul>
<li><code>vApplicationGetTimerTaskMemory</code>
<ul>
<li><em>if <code>configUSE_TIMERS</code> is 1</em></li>
</ul>
</li>
<li><code>vApplicationGetIdleTaskMemory</code></li>
</ul>
<h4 id="3421-vapplicationgettimertaskmemory"><a class="header" href="#3421-vapplicationgettimertaskmemory">3.4.2.1 vApplicationGetTimerTaskMemory</a></h4>
<p>If <code>configSUPPORT_STATIC_ALLOCATION</code> and <code>configUSE_TIMERS</code> are both enabled, the kernel will call <code>vApplicationGetTimerTaskMemory()</code>
to allow the application to create and return a memory buffer for the timer task TCB and the timer task stack. The function will
also return the size of the timer task stack. A suggested implementation of the timer task memory function is shown in listing 3.13.</p>
<p><a name="list3.13" title="Listing 3.13 Typical implementation of vApplicationGetTimerTaskMemory"></a></p>
<pre><code class="language-c">void vApplicationGetTimerTaskMemory( StaticTask_t **ppxTimerTaskTCBBuffer,
                                     StackType_t **ppxTimerTaskStackBuffer,
                                     uint32_t *pulTimerTaskStackSize )
{
  /* If the buffers to be provided to the Timer task are declared inside this
  function then they must be declared static - otherwise they will be allocated on
  the stack and hence would not exists after this function exits. */
  static StaticTask_t xTimerTaskTCB;
  static StackType_t uxTimerTaskStack[ configMINIMAL_STACK_SIZE ];

  /* Pass out a pointer to the StaticTask_t structure in which the Timer task's
  state will be stored. */
  *ppxTimerTaskTCBBuffer = &amp;xTimerTaskTCB;

  /* Pass out the array that will be used as the Timer task's stack. */
  *ppxTimerTaskStackBuffer = uxTimerTaskStack;

  /* Pass out the stack size of the array pointed to by *ppxTimerTaskStackBuffer.
  Note the stack size is a count of StackType_t */
  *pulTimerTaskStackSize = sizeof(uxTimerTaskStack) / sizeof(*uxTimerTaskStack);
}
</code></pre>
<p><em><strong>Listing 3.13</strong></em> <em>Typical implementation of vApplicationGetTimerTaskMemory</em></p>
<p>Since there is only a single timer task in any system including SMP, a valid solution to the timer task memory problem
is to allocate static buffers in the <code>vApplicationGetTimeTaskMemory()</code> function and return the buffer pointers to the kernel.</p>
<h4 id="3422-vapplicationgetidletaskmemory"><a class="header" href="#3422-vapplicationgetidletaskmemory">3.4.2.2 vApplicationGetIdleTaskMemory</a></h4>
<p>The idle task is run when a core runs out of scheduled work. The idle task performs some housekeeping and can also trigger
the user's <code>vTaskIdleHook()</code> if it is enabled.  In a symetric multiprocessing system (SMP) there are also non-housekeeping
idle tasks for each of the remaining cores, but these are statically allocated internally to <code>configMINIMUM_STACK_SIZE</code> bytes.</p>
<p>The <code>vApplicationGetIdleTaskMemory</code> function is called to allow the application to create the needed buffers for the "main"
idle task. Listing 3.14 shows a typical implementation of the <code>vApplicationIdleTaskMemory()</code> function using static local
variables to create the needed buffers.</p>
<p><a name="list3.14" title="Listing 3.14 Typical implementation of vApplicationGetIdleTaskMemory"></a></p>
<pre><code class="language-c">void vApplicationGetIdleTaskMemory( StaticTask_t **ppxIdleTaskTCBBuffer,
                                    StackType_t **ppxIdleTaskStackBuffer,
                                    uint32_t *pulIdleTaskStackSize )
{
  static StaticTask_t xIdleTaskTCB;
  static StackType_t uxIdleTaskStack[ configMINIMAL_STACK_SIZE ];

  *ppxIdleTaskTCBBuffer = &amp;xIdleTaskTCB;
  *ppxIdleTaskStackBuffer = uxIdleTaskStack;
  *pulIdleTaskStackSize = configMINIMAL_STACK_SIZE;
}
</code></pre>
<p><em><strong>Listing 3.14</strong></em> <em>Typical implementation of vApplicationGetIdleTaskMemory</em></p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="ch02.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="ch04.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="ch02.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="ch04.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->


    </div>
    </body>
</html>
